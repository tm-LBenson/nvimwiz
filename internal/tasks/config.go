package tasks

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const managedInitMarker = "-- nvimwiz managed"

func writeConfig(logf func(string), opts Options) error {
	_, _, _, configRoot, err := userPaths()
	if err != nil {
		return err
	}

	// Normalize options
	if opts.ProjectsDir == "" {
		opts.ProjectsDir = "~/projects"
	}
	if opts.Leader == "" {
		opts.Leader = " "
	}
	if opts.LocalLeader == "" {
		opts.LocalLeader = " "
	}
	if opts.ConfigMode == "" {
		opts.ConfigMode = "managed"
	}

	nvimwizDir := filepath.Join(configRoot, "lua", "nvimwiz")
	generatedDir := filepath.Join(nvimwizDir, "generated")

	if err := os.MkdirAll(generatedDir, 0o755); err != nil {
		return err
	}

	// Always write loader + generated modules. This enables both "managed" and "integrate" modes.
	loaderPath := filepath.Join(nvimwizDir, "loader.lua")
	if err := os.WriteFile(loaderPath, []byte(generateLoaderLua()), 0o644); err != nil {
		return err
	}
	logf("[OK] Wrote " + loaderPath)

	// Generated modules (safe to overwrite)
	files := map[string]string{
		filepath.Join(generatedDir, "settings.lua"): generateSettingsLua(opts),
		filepath.Join(generatedDir, "projects.lua"): generateProjectsLua(opts),
		filepath.Join(generatedDir, "lsp.lua"):      generateLSPLua(opts),
		filepath.Join(generatedDir, "plugins.lua"):  generatePluginsLua(opts),
	}
	for path, content := range files {
		if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
			return err
		}
		logf("[OK] Wrote " + path)
	}

	// Create user overrides file once; never overwrite.
	userPath := filepath.Join(nvimwizDir, "user.lua")
	if !exists(userPath) {
		if err := os.WriteFile(userPath, []byte(defaultUserLua()), 0o644); err != nil {
			return err
		}
		logf("[OK] Created " + userPath + " (you can edit this safely)")
	}

	initPath := filepath.Join(configRoot, "init.lua")
	mode := strings.ToLower(strings.TrimSpace(opts.ConfigMode))
	if mode != "integrate" {
		mode = "managed"
	}

	if mode == "integrate" {
		if !exists(initPath) {
			// No existing init.lua to protect; just write our managed stub.
			mode = "managed"
			logf("[INFO] No existing init.lua found; using managed mode.")
		}
	}

	if mode == "managed" {
		if err := writeManagedInit(logf, initPath); err != nil {
			return err
		}
	} else {
		logf("[INFO] Integrate mode selected: init.lua was not modified.")
		logf("[INFO] To enable nvimwiz config, add this line to your init.lua:")
		logf("[INFO]   require(\"nvimwiz.loader\")")
	}

	return nil
}

func writeManagedInit(logf func(string), initPath string) error {
	if exists(initPath) {
		b, err := os.ReadFile(initPath)
		if err != nil {
			return err
		}
		if !strings.Contains(string(b), managedInitMarker) {
			bak := initPath + ".bak-" + time.Now().Format("20060102-150405")
			if err := os.Rename(initPath, bak); err != nil {
				return fmt.Errorf("backup existing init.lua: %w", err)
			}
			logf("[INFO] Backed up existing init.lua to " + bak)
		}
	}

	if err := os.MkdirAll(filepath.Dir(initPath), 0o755); err != nil {
		return err
	}

	content := strings.Join([]string{
		managedInitMarker,
		"-- This file is managed by nvimwiz.",
		"-- Your safe customization file is: lua/nvimwiz/user.lua",
		"",
		"require(\"nvimwiz.loader\")",
		"",
	}, "\n")

	if err := os.WriteFile(initPath, []byte(content), 0o644); err != nil {
		return err
	}
	logf("[OK] Wrote " + initPath)
	return nil
}

func generateLoaderLua() string {
	// Loader is safe to require from an existing init.lua.
	return strings.Join([]string{
		"-- Generated by nvimwiz",
		"-- Loads generated modules, then a user override module.",
		"-- Generated modules live under: lua/nvimwiz/generated/",
		"",
		"pcall(require, \"nvimwiz.generated.settings\")",
		"pcall(require, \"nvimwiz.generated.projects\")",
		"pcall(require, \"nvimwiz.generated.lsp\")",
		"pcall(require, \"nvimwiz.generated.plugins\")",
		"pcall(require, \"nvimwiz.user\")",
		"",
	}, "\n")
}

func generateSettingsLua(opts Options) string {
	var b strings.Builder
	b.WriteString("-- Generated by nvimwiz\n")
	b.WriteString("-- Settings + leader keys\n\n")
	b.WriteString(fmt.Sprintf("vim.g.mapleader = %s\n", luaQuote(opts.Leader)))
	b.WriteString(fmt.Sprintf("vim.g.maplocalleader = %s\n\n", luaQuote(opts.LocalLeader)))

	b.WriteString("vim.opt.number = true\n")
	b.WriteString("vim.opt.relativenumber = true\n")
	b.WriteString("vim.opt.mouse = \"a\"\n")
	b.WriteString("vim.opt.clipboard = \"unnamedplus\"\n")
	b.WriteString("vim.opt.termguicolors = true\n")
	b.WriteString("vim.opt.signcolumn = \"yes\"\n")
	b.WriteString("vim.opt.updatetime = 250\n")
	b.WriteString("vim.opt.timeoutlen = 400\n")
	b.WriteString("vim.opt.completeopt = { \"menu\", \"menuone\", \"noselect\" }\n")
	b.WriteString("vim.opt.splitright = true\n")
	b.WriteString("vim.opt.splitbelow = true\n")
	b.WriteString("vim.opt.ignorecase = true\n")
	b.WriteString("vim.opt.smartcase = true\n")
	b.WriteString("vim.opt.expandtab = true\n")
	b.WriteString("vim.opt.shiftwidth = 2\n")
	b.WriteString("vim.opt.tabstop = 2\n")
	b.WriteString("\n")

	return b.String()
}

func generateProjectsLua(opts Options) string {
	projects := opts.ProjectsDir
	if projects == "" {
		projects = "~/projects"
	}

	var b strings.Builder
	b.WriteString("-- Generated by nvimwiz\n")
	b.WriteString("-- Projects dashboard + project picker\n\n")
	b.WriteString(fmt.Sprintf("local projects_dir = vim.fn.expand(%s)\n", luaQuote(projects)))
	b.WriteString(fmt.Sprintf("local enable_tree = %s\n", luaBool(opts.EnableTree)))
	b.WriteString(fmt.Sprintf("local enable_telescope = %s\n\n", luaBool(opts.EnableTelescope)))

	b.WriteString(`local function ensure_projects_dir()
  if vim.fn.isdirectory(projects_dir) == 0 then
    vim.fn.mkdir(projects_dir, "p")
  end
end

local function list_projects()
  ensure_projects_dir()
  local dirs = {}
  local ok, iter = pcall(vim.fs.dir, projects_dir)
  if not ok then return dirs end
  for name, t in iter do
    if t == "directory" and not name:match("^%.") then
      dirs[#dirs + 1] = name
    end
  end
  table.sort(dirs)
  return dirs
end

local function open_project(name)
  if not name or name == "" then return end
  local path = projects_dir .. "/" .. name
  if vim.fn.isdirectory(path) == 0 then
    vim.notify("Project does not exist: " .. path, vim.log.levels.ERROR)
    return
  end

  vim.cmd("cd " .. vim.fn.fnameescape(path))

  if enable_tree then
    pcall(vim.cmd, "NvimTreeOpen")
  end

  if enable_telescope then
    local ok, tb = pcall(require, "telescope.builtin")
    if ok then
      tb.find_files({ cwd = path, hidden = true })
      return
    end
  end

  -- fallback: open the directory
  vim.cmd("edit " .. vim.fn.fnameescape(path))
end

local function pick_project()
  local dirs = list_projects()
  if #dirs == 0 then
    vim.notify("No projects found in " .. projects_dir, vim.log.levels.WARN)
    return
  end
  vim.ui.select(dirs, { prompt = "Select project" }, open_project)
end

local function new_project()
  vim.ui.input({ prompt = "New project name: " }, function(name)
    if not name or name == "" then return end
    ensure_projects_dir()
    local path = projects_dir .. "/" .. name
    vim.fn.mkdir(path, "p")
    open_project(name)
  end)
end

vim.api.nvim_create_user_command("Projects", pick_project, {})
vim.api.nvim_create_user_command("NewProject", new_project, {})

vim.keymap.set("n", "<leader>pp", pick_project, { desc = "Projects" })
vim.keymap.set("n", "<leader>pn", new_project,  { desc = "New project" })

-- Minimal dashboard (no plugin)
local function dashboard_render(buf)
  local dirs = list_projects()
  local lines = {
    "Neovim Projects",
    "===============",
    "",
    "Projects dir: " .. projects_dir,
    "",
    "[p] pick project   [n] new project   [e] explore dir   [r] refresh   [q] quit",
    "",
  }

  if #dirs == 0 then
    table.insert(lines, "No projects found. Press 'n' to create one.")
  else
    table.insert(lines, "Projects:")
    for i, name in ipairs(dirs) do
      table.insert(lines, string.format("  %2d. %s", i, name))
    end
    table.insert(lines, "")
    table.insert(lines, "Move to a project line and press <Enter> to open.")
  end

  vim.bo[buf].modifiable = true
  vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)
  vim.bo[buf].modifiable = false
end

local function dashboard_open()
  if vim.fn.argc() > 0 then return end
  if vim.api.nvim_buf_get_name(0) ~= "" then return end
  if vim.bo.filetype ~= "" then return end

  local buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_set_current_buf(buf)

  vim.bo[buf].buftype = "nofile"
  vim.bo[buf].bufhidden = "wipe"
  vim.bo[buf].swapfile = false
  vim.bo[buf].modifiable = false

  dashboard_render(buf)

  local function map(key, fn, desc)
    vim.keymap.set("n", key, fn, { buffer = buf, silent = true, nowait = true, desc = desc })
  end

  map("p", pick_project, "Pick project")
  map("n", new_project, "New project")
  map("e", function() vim.cmd("edit " .. vim.fn.fnameescape(projects_dir)) end, "Explore projects dir")
  map("r", function() dashboard_render(buf) end, "Refresh")
  map("q", function() vim.cmd("qa") end, "Quit")

  map("<CR>", function()
    local line = vim.api.nvim_get_current_line()
    local num = tonumber(line:match("^%s*(%d+)%."))
    if not num then return end
    local dirs = list_projects()
    local name = dirs[num]
    if name then open_project(name) end
  end, "Open project")
end

vim.api.nvim_create_autocmd("VimEnter", { callback = dashboard_open, once = true })
`)

	return b.String()
}

func generateLSPLua(opts Options) string {
	var b strings.Builder
	b.WriteString("-- Generated by nvimwiz\n")
	b.WriteString("-- Shared LSP helpers (on_attach + capabilities)\n\n")

	if !opts.EnableLSP {
		b.WriteString("return {\n  on_attach = function() end,\n  capabilities = vim.lsp.protocol.make_client_capabilities(),\n}\n")
		return b.String()
	}

	b.WriteString(`local M = {}

function M.on_attach(client, bufnr)
  local function nmap(keys, func, desc)
    vim.keymap.set("n", keys, func, { buffer = bufnr, desc = desc })
  end

  nmap("gd", vim.lsp.buf.definition, "Go to definition")
  nmap("gr", vim.lsp.buf.references, "References")
  nmap("gI", vim.lsp.buf.implementation, "Implementation")
  nmap("K",  vim.lsp.buf.hover, "Hover")
  nmap("<leader>rn", vim.lsp.buf.rename, "Rename")
  nmap("<leader>ca", vim.lsp.buf.code_action, "Code action")
  nmap("<leader>f", function() vim.lsp.buf.format({ async = true }) end, "Format")

  if vim.lsp.completion and vim.lsp.completion.enable then
    pcall(vim.lsp.completion.enable, true, client.id, bufnr, { autotrigger = true })
  else
    vim.bo[bufnr].omnifunc = "v:lua.vim.lsp.omnifunc"
  end
end

M.capabilities = vim.lsp.protocol.make_client_capabilities()
M.capabilities.textDocument.completion.completionItem.snippetSupport = true

return M
`)
	return b.String()
}

func generatePluginsLua(opts Options) string {
	var b strings.Builder
	b.WriteString("-- Generated by nvimwiz\n")
	b.WriteString("-- Plugin manager + plugins\n\n")

	b.WriteString(`-- lazy.nvim bootstrap
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
local uv = vim.uv or vim.loop
if not uv.fs_stat(lazypath) then
  vim.fn.system({
    "git", "clone", "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable",
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

local plugins = {
`)

	if opts.EnableTelescope {
		b.WriteString(`  {
    "nvim-telescope/telescope.nvim",
    dependencies = { "nvim-lua/plenary.nvim" },
    config = function()
      require("telescope").setup({})
      local builtin = require("telescope.builtin")
      vim.keymap.set("n", "<leader>ff", builtin.find_files, { desc = "Find files" })
      vim.keymap.set("n", "<leader>fg", builtin.live_grep,  { desc = "Live grep" })
      vim.keymap.set("n", "<leader>fb", builtin.buffers,    { desc = "Buffers" })
    end,
  },
`)
	}

	if opts.EnableTree {
		b.WriteString(`  {
    "nvim-tree/nvim-tree.lua",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    lazy = false,
    config = function()
      require("nvim-tree").setup({
        view = { width = 32, side = "left" },
        renderer = { group_empty = true },
        filters = { dotfiles = false },
      })
      vim.keymap.set("n", "<leader>e", "<cmd>NvimTreeToggle<CR>", { desc = "Explorer" })
      vim.keymap.set("n", "<leader>o", "<cmd>NvimTreeFocus<CR>",  { desc = "Focus explorer" })
    end,
  },
`)
	}

	if opts.EnableLSP {
		b.WriteString(`  { "williamboman/mason.nvim", config = true },
  { "neovim/nvim-lspconfig" },
  {
    "williamboman/mason-lspconfig.nvim",
    dependencies = { "williamboman/mason.nvim", "neovim/nvim-lspconfig" },
    config = function()
      local lspconfig = require("lspconfig")
      local lsp = require("nvimwiz.generated.lsp")

      local servers = { "pyright", "html", "cssls", "gopls", "bashls", "lua_ls" }
      if lspconfig.ts_ls then
        table.insert(servers, "ts_ls")
      elseif lspconfig.tsserver then
        table.insert(servers, "tsserver")
      end

      require("mason-lspconfig").setup({
        ensure_installed = servers,
        automatic_installation = true,
      })

      local function setup(server, extra)
        extra = extra or {}
        extra.on_attach = lsp.on_attach
        extra.capabilities = lsp.capabilities
        lspconfig[server].setup(extra)
      end

      if lspconfig.ts_ls then
        setup("ts_ls")
      elseif lspconfig.tsserver then
        setup("tsserver")
      end

      setup("pyright")
      setup("html")
      setup("cssls")
      setup("gopls")
      setup("bashls")
      setup("lua_ls", {
        settings = { Lua = { diagnostics = { globals = { "vim" } } } },
      })
    end,
  },
`)
	}

	if opts.EnableJava {
		b.WriteString(`  {
    "mfussenegger/nvim-jdtls",
    ft = { "java" },
    config = function()
      local jdtls = require("jdtls")
      local util = require("lspconfig.util")
      local lsp = require("nvimwiz.generated.lsp")

      local function start()
        local root = util.root_pattern(".git", "mvnw", "gradlew", "pom.xml", "build.gradle", "settings.gradle")(vim.fn.getcwd())
        if not root then return end

        local project_name = vim.fn.fnamemodify(root, ":t")
        local workspace_dir = vim.fn.stdpath("data") .. "/jdtls-workspace/" .. project_name
        vim.fn.mkdir(workspace_dir, "p")

        jdtls.start_or_attach({
          cmd = { "jdtls", "-data", workspace_dir },
          root_dir = root,
          on_attach = lsp.on_attach,
          capabilities = lsp.capabilities,
        })
      end

      start()
      vim.api.nvim_create_autocmd("FileType", { pattern = "java", callback = start })
    end,
  },
`)
	}

	b.WriteString(`}

require("lazy").setup(plugins, {
  checker = { enabled = false },
})
`)

	return b.String()
}

func defaultUserLua() string {
	return strings.Join([]string{
		"-- nvimwiz user overrides",
		"-- This file is NOT overwritten by nvimwiz.",
		"-- Put your personal customizations here: keymaps, options, plugins, etc.",
		"",
		"-- Example:",
		"-- vim.keymap.set(\"n\", \"<leader>xx\", function() print(\"hello\") end, { desc = \"Example\" })",
		"",
	}, "\n")
}

func luaQuote(s string) string {
	// Use Go's %q to produce a valid quoted string for Lua.
	// For our use case (leader keys, paths), this is sufficient.
	return fmt.Sprintf("%q", s)
}

func luaBool(v bool) string {
	if v {
		return "true"
	}
	return "false"
}

func exists(p string) bool {
	_, err := os.Stat(p)
	return err == nil
}
